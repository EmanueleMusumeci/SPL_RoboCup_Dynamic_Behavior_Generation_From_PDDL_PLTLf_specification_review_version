/**
 * @file LibCheckProvider.cpp
 *
 * Performs some checks of the behavior control module such as
 * - How often is a MotionRequest set?
 * - How often is a HeadMotionRequest set?
 *
 * @author Tim Laue
 */

#include "LibCheckProvider.h"
#include <iostream>
#define SQ(x) x*x

MAKE_MODULE(LibCheckProvider, behaviorControl);

int sign(float n){
  if(n > 0){
    return 1;
  }else if(n == 0){
    return 0;
  }else{
    return -1;
  }
}

LibCheckProvider::LibCheckProvider(): goalie_displacement(300.f),
        angleToGoal(0.f), angleToMyGoal(0.f), kickAngle(0.f), correctionKickAngle(0.f), ballOutOnLeft(false)
{
    SPQR::ConfigurationParameters();
}

void LibCheckProvider::update(LibCheck& libCheck)
{
  reset();
  libCheck.timeSinceBallWasSeen = theFrameInfo.getTimeSince(theTeamBallModel.timeWhenLastSeen);
  libCheck.isGoalieInStartingPosition = isGoalieInStartingPosition();
  libCheck.isBallInArea = isBallInArea();
  libCheck.isGoalieInAngle = isGoalieInAngle();
  libCheck.isGoalieInArea = isGoalieInArea();
  libCheck.isGoalieInKickAwayRange = isGoalieInKickAwayRange();
  libCheck.isBallInKickAwayRange = isBallInKickAwayRange();

  libCheck.norm = [&](float x, float y) -> float
  {
    return (float)(sqrt((x*x) + (y*y)));
  };

  libCheck.inc = [this](LibCheck::CheckedOutput outputToCheck) {inc(outputToCheck);};
  libCheck.setArm = [this](Arms::Arm arm)
  {
    setArmsInThisFrame[arm] = true;
  };
  libCheck.wasSetArm = [this](Arms::Arm arm) -> bool
  {
    return setArmsInThisFrame[arm];
  };
  libCheck.performCheck = [this](const MotionRequest& theMotionRequest)
  {
    checkOutputs(theActivationGraph, static_cast<LibCheck::CheckedOutput>(0), LibCheck::firstTeamCheckedOutput);
    checkMotionRequest(theActivationGraph, theMotionRequest);
  };
  libCheck.performTeamCheck = [this]()
  {
    checkOutputs(theTeamActivationGraph, LibCheck::firstTeamCheckedOutput, LibCheck::numOfCheckedOutputs);
  };
  libCheck.myReadyPosition = [this]() -> Pose2f{
    
    Pose2f strikerPose = Pose2f(0.f, -1000.f, 0.f);
    if(theGameInfo.kickingTeam == theOwnTeamInfo.teamNumber){
      strikerPose = Pose2f(0.f, -500.f, 0.f);
    }else{
      strikerPose = Pose2f(0.f, -1000.f, 0.f);
    }
    
    Pose2f goaliePose = Pose2f(0.f, theFieldDimensions.xPosOwnGroundline + 200.f, 0.f);
    Pose2f defenderPose = Pose2f(0.f, theFieldDimensions.xPosOwnGroundline + 1000.f, -1000.f);
    Pose2f jollyPose = Pose2f(0.f, -500.f, -1500.f);
    Pose2f supporterPose = Pose2f(0.f, theFieldDimensions.xPosOwnGroundline + 1700.f, 800.f);
    int activeTeam = 0;
    int lowerNumbers = 0;
    if(theRobotInfo.penalty == PENALTY_NONE){
      activeTeam++;
    }
    if(theRobotInfo.number == 1){
        return goaliePose;
    }
    for( auto teammate : theTeamData.teammates ){
      if(teammate.status != Teammate::PENALIZED && teammate.number != 1){
        activeTeam ++;
        if(teammate.number < theRobotInfo.number){
          lowerNumbers ++;
        }
      }
    }
    switch(activeTeam){
      case 0: return Pose2f(0.f,0.f,0.f); break;

      case 1: return strikerPose;
              break;

      case 2: if(lowerNumbers <= 0){
                return defenderPose;
              }else{
                return strikerPose;
              } 
              break;

      case 3: if(lowerNumbers == 2){
                  return strikerPose;
                }else if(lowerNumbers == 1){
                  return defenderPose;
                }else if(lowerNumbers == 0){
                  return supporterPose;
                }
                break;

      case 4: if(theRobotInfo.number == 3){
                return strikerPose;
              }else if(theRobotInfo.number == 2){
                return supporterPose;
              }else if (theRobotInfo.number == 5){
                return defenderPose;
              }else if(theRobotInfo.number == 4){
                return jollyPose;
              }
    }

    return strikerPose;

  };
  libCheck.distance = [this](const Pose2f p1, const Pose2f p2) -> float{
    return static_cast<float>( std::sqrt( std::pow(p2.translation.x() - p1.translation.x(), 2) + 
      std::pow(p2.translation.y() - p1.translation.y(), 2) ) );

  };
  libCheck.refineTarget = [this](const Pose2f t, const float d) -> Pose2f{
    Rangef zeroTreshold = Rangef({-0.1f, 0.1f});
    float diffX = t.translation.x() - theRobotPose.translation.x();
    float diffY = t.translation.y() - theRobotPose.translation.y();

    //Check if target and robot have the same X
    if(zeroTreshold.isInside(diffX)){
      //if they also have the same y keep the same target
      if(zeroTreshold.isInside(diffY)){
        return t;
      }else{
        return Pose2f(theRobotPose.translation.x(), theRobotPose.translation.y() + (d * sign(diffY) ));
      }
    }// end of if X1 == X2

    //Check if target and robot have the same Y
    if(zeroTreshold.isInside(diffY)){
      //if they also have the same x keep the same target
      if(zeroTreshold.isInside(diffX)){
        return t;
      }else{
        return Pose2f( theRobotPose.translation.x() + (d * sign(diffX)) , theRobotPose.translation.y());
      }
    }// end of if Y1 == Y2

    //if the distance is still lower than d, than just return t
    if(distance(theRobotPose, t) <= d ){
      return t;
    }

    // Y = mX + q
    float m = diffY/diffX;
    float q = -theRobotPose.translation.y() -theRobotPose.translation.x()*m;  
    // just for readability
    float x1 = theRobotPose.translation.x();
    float y1 = theRobotPose.translation.y();
    
    float a = SQ(m) + 1;
    float b = 2*m -2*y1*m -2*x1;
    float c = SQ(q) -2*y1*q +SQ(y1) +SQ(x1) -SQ(d);
    
    //Use the delta formula
    float X = (-b + std::sqrt(SQ(b) - 4*a*c))/(2*a);
    //classical line equation
    float Y = m*X + q;

    return Pose2f(X,Y);
  };

  libCheck.projectGazeOntoOpponentGroundline = [this]() -> float{
      return theRobotPose.translation.y() + std::abs(theFieldDimensions.xPosOpponentGoal - theRobotPose.translation.x())*tan(theRobotPose.rotation);
  };

  //RECENTLY ADDED
  //Emanuele M
  //TODO
  libCheck.areaValueHeuristic = [this](const float begin, const float end) -> float{
    return 0.0;
  };
  //RECENTLY MODIFIED
  //Emanuele M
  libCheck.computeFreeAreas = [this]() -> std::vector<FreeGoalTargetableArea>{

    //my pose
    Pose2f myPose = Pose2f(theRobotPose.translation);
    
    //build vector of opponents
    std::vector<Obstacle> opponents;
    for(auto obs : theTeamPlayersModel.obstacles){
      opponents.push_back(obs);
    }

    //array of opponent goal poles positions:
    //CHECK FOR NEW ROBOCUP FIELD SPECIFICATIONS
    Pose2f goalPoints[2];
    goalPoints[0].translation.x() = (float)theFieldDimensions.xPosOpponentGroundline;
    goalPoints[1].translation.x() = (float)theFieldDimensions.xPosOpponentGroundline;
    goalPoints[0].translation.y() = 730.;
    goalPoints[1].translation.y() = -730.;

    std::vector<float> leftPoints;
    std::vector<float> rightPoints;
    std::vector<FreeGoalTargetableArea> freeAreas;


    //UNUSED
    //my distance from opponent goal
    float div1;
    if((goalPoints[0].translation.x() - myPose.translation.x() ) == 0){
      div1 = 0.1f;
    } else {
      div1 = (float)((goalPoints[0].translation.x() - myPose.translation.x()));
    }

    // y = ((4500 - x1)/(x2 - x1))*(y2 -y1) + y1

    // float firstM = (goalPoints[0].translation.y() - myPose.translation.y() )/div1;
    // float secondM = (goalPoints[1].translation.y() - myPose.translation.y() )/div2;
    unsigned i, k;
    Obstacle swapper;

    //first sweep: sort the opponents in vector based on the y coordinate of their left points (as obstacles, it is the leftmost point i see)
    for(i = 0; i < opponents.size(); i++){
        for(k = 0; k < opponents.size(); k++){
            if(opponents.at(i).left.y() > opponents.at(k).left.y() ){
                swapper = opponents.at(k);
                opponents.at(k) = opponents.at(i);
                opponents.at(i) = swapper;
            }
        }
    }

    //second sweep: push the globalized left and right points of each obstacle 
    for(i = 0; i < opponents.size(); i++){
        if((opponents.at(i).left.x() - myPose.translation.x()) == 0){
          div1 = 0.1f;
        } else {
          div1 = (float)(opponents.at(i).left.x() - myPose.translation.x());
        }

        float y = ((theFieldDimensions.xPosOpponentGroundline - myPose.translation.x())/div1)*(opponents.at(i).left.y() - myPose.translation.y()) + myPose.translation.y();
        leftPoints.push_back(y);
    }

    for(i = 0; i < opponents.size(); i++){
        if((opponents.at(i).right.x() - myPose.translation.x()) == 0){
          div1 = 0.1f;
        } else {
          div1 = (float)(opponents.at(i).right.x() - myPose.translation.x());
        }

        float y = ((theFieldDimensions.xPosOpponentGroundline - myPose.translation.x())/div1)*(opponents.at(i).right.y() - myPose.translation.y()) + myPose.translation.y();
        rightPoints.push_back(y);
    }

    //gestisco caso in cui tutti gli obstacle sono fuori dalla porta
    bool noneInside = true;
    float begin = 730.;
    float end = -730.;

    for(i = 0; i < leftPoints.size(); i++){
        //caso 1
        if((leftPoints.at(i) < 730. && leftPoints.at(i) > -730.) || (rightPoints.at(i) < 730. && rightPoints.at(i) > -730.)){
            noneInside = false;
        }
        if(leftPoints.at(i) > 730. && rightPoints.at(i) < 730.){
            begin = rightPoints.at(i);

        }
        if(leftPoints.at(i) > -730. && rightPoints.at(i) < -730.){
            end = leftPoints.at(i);

        }
    }
    if(noneInside == true){
    //    freeAreas.push_back(begin);
      freeAreas.push_back(FreeGoalTargetableArea(begin, end, areaValueHeuristic(begin,end)));
    //    freeAreas.push_back(end);
        return freeAreas;
    }
    std::vector<float> freeAreasPoints;
    freeAreasPoints.push_back(begin);
    for(i = 0; i < leftPoints.size(); i++){
        if(leftPoints.at(i) < begin && leftPoints.at(i) > end){
            freeAreasPoints.push_back(leftPoints.at(i));
        }
        if(rightPoints.at(i) > end && rightPoints.at(i) < begin){
            freeAreasPoints.push_back(rightPoints.at(i));
        }
    }
    freeAreasPoints.push_back(end);

    //FIND NEAREST USABLE FREE AREA AND DETERMINE MOST ACCESSIBLE TARGET
    if(freeAreas.size()%2 == 0)
    {
      for(i = 0; i < freeAreasPoints.size() -1; i+=2)
      {
        freeAreas.push_back(FreeGoalTargetableArea(freeAreasPoints.at(i), freeAreasPoints.at(i+1), areaValueHeuristic(freeAreasPoints.at(i),freeAreasPoints.at(i+1))));
      }
    }
    else
    {
      for(i = 1; i < freeAreasPoints.size() -1; i+=2)
      {
        freeAreas.push_back(FreeGoalTargetableArea(freeAreasPoints.at(i), freeAreasPoints.at(i+1), areaValueHeuristic(freeAreasPoints.at(i),freeAreasPoints.at(i+1))));
      }
    }

    return freeAreas;
  };

  libCheck.goalTarget = [this]() -> Pose2f{
    //std::vector<FreeGoalTargetableArea> freeAreas = computeFreeAreas();
    std::vector<FreeGoalTargetableArea> freeAreas = theOpponentGoalModel.freeGoalTargetableAreas;

    for(auto area : freeAreas)
    {
      std::cout << ("KICKING: FreeGoalTargetableArea: ("+std::to_string(area.begin)+","+std::to_string(area.end)+")") << "\n";
    }

    //Find nearest opponent
    //float nearestObstacleThreshold = 200.f;
    std::vector<Obstacle> opponents;
    for(auto obs : theTeamPlayersModel.obstacles){
      opponents.push_back(obs);
    }

    float ARBITRARILY_HIGH_VALUE = 100000.f;
    float minOpponentDistance=ARBITRARILY_HIGH_VALUE;
    Obstacle nearestOpponent;
    
    for(unsigned i = 0; i < opponents.size(); i++){
      if(distance(theRobotPose.translation,opponents.at(i).center)<minOpponentDistance){
        minOpponentDistance = distance(theRobotPose.translation,opponents.at(i).center);
        nearestOpponent = opponents.at(i);
      }
    }

    //project my line of view onto the goal line
    float myGazeProjection = theOpponentGoalModel.myGazeProjection;
    std::cout << "myGazeProjection: "+std::to_string(myGazeProjection) << "\n";

    float GOAL_DISTANCE_THRESHOLD = 300.f;

    //TODO: se vuoi, controllo che il punto in cui vado a calciare sia > del più vicino limite della free area + il raggio della palla

    float targetPoint = 0;

    //CASE 1: I'm near the goal post -> choose the nearest free area
    if(std::abs(theRobotPose.translation.x()-theFieldDimensions.xPosOpponentGoal)<GOAL_DISTANCE_THRESHOLD){
      for(unsigned i = 0; i < freeAreas.size(); i++){
        //CASE 1.1: Looking at free area directly
        if(myGazeProjection<freeAreas.at(i).begin && myGazeProjection>freeAreas.at(i).end){
          targetPoint = myGazeProjection;
        }
        //CASE 1.2: Looking away from free area
        //TODO: Find nearest free area and target the nearest accessible point
        else
        {
          
        }
      }
    }
    //CASE 2: I'm far away from the goal post -> find the largest free area (MIGHT BECOME "FIND THE BEST FREE AREA, BASED ON ITS HEURISTIC VALUE")
    else
    {
      float maxInterval = 0;
      unsigned maxIndex = 0;
      //FIND LARGEST FREE AREA AND DETERMINE THE MOST ACCESSIBLE TARGET
      for(unsigned i = 0; i < freeAreas.size(); i++){
        if(maxInterval < freeAreas.at(i).interval){
          maxInterval = freeAreas.at(i).interval;
          maxIndex = i;
          targetPoint = freeAreas.at(i).midpoint;
        }
      }
    }

    Pose2f target;
    if (theRobotPose.translation.x() >= (theFieldDimensions.xPosOpponentGroundline - 600.f) &&
            std::abs(theRobotPose.translation.y()) < 500.f )
        target = Pose2f(theFieldDimensions.xPosOpponentGroundline + 1000.f, targetPoint);
    else
        target = Pose2f(theFieldDimensions.xPosOpponentGroundline, targetPoint);
      return target;
  };
  
    libCheck.glob2Rel = [&](float x, float y) -> Pose2f
  {
      Vector2f result;
      float theta = 0;
      float tempX = x - theRobotPose.translation.x();
      float tempY = y - theRobotPose.translation.y();

      result.x() = (float)(tempX * cos(theRobotPose.rotation) + tempY * sin(theRobotPose.rotation));
      result.y() = (float)(-tempX * sin(theRobotPose.rotation) + tempY * cos(theRobotPose.rotation));

      return Pose2f(theta , result.x(),result.y());
  };
  
  
      libCheck.defenderDynamicY = [&]() -> float
    {
        float x2 = theTeamBallModel.position.x();
        float y2 = theTeamBallModel.position.y();
        float x1 = -4500.f;   // first goalpost for defender
        float y1 = (y2/(std::abs(y2)+1))*750.f;   // first goalpost for defender
        float defenderBallY = (( libCheck.defenderPosition.x()-x1 )*( y2-y1 ))/( x2-x1 ) + y1;

        return defenderBallY-(y2/(std::abs(y2)+1))*100.f;
    };
    
  libCheck.rel2Glob = [&](float x, float y) -> Pose2f
  {
      Vector2f result;
      float rho = (float)(sqrt((x * x) + (y * y)));

      result.x() = (float)(theRobotPose.translation.x() + (rho * cos(theRobotPose.rotation + atan2(y,x))));
      result.y() = (float)(theRobotPose.translation.y() + (rho * sin(theRobotPose.rotation + atan2(y,x))));

      return Pose2f(result.x(),result.y());
  };
  
  libCheck.getSupporterMarkPosition = [&] () -> Vector2f
{
    Vector2f strikerPosition;
    Vector2f defenderPosition;

    float STAY_BACK_DISTANCE = 800.f;
    if(theTeamBallModel.position.x() < theFieldDimensions.xPosOwnGroundline + 1500)
      STAY_BACK_DISTANCE = 0;
    else if(theTeamBallModel.position.x() < theFieldDimensions.xPosOwnGroundline / 4.f)
      STAY_BACK_DISTANCE = 350.f;

    for(const auto& teammate : theTeamData.teammates){
        if(teammate.role == Role::RoleType::striker) {
            strikerPosition = Vector2f(teammate.theRobotPose.translation.x(),teammate.theRobotPose.translation.y());
        }
        else if(teammate.role == Role::RoleType::defender) {
            defenderPosition = Vector2f(teammate.theRobotPose.translation.x(),teammate.theRobotPose.translation.y());
        }
    }

    Vector2f passPointA = theTeamBallModel.position;

    std::vector<Vector2f> PossibleMarkTargets;
    for(auto const& obs : theTeamPlayersModel.obstacles){
        if(obs.isOpponent() && obs.center.x() < 500.f){
            bool skip = false;
            for(auto const& obs2 : theTeamPlayersModel.obstacles){
                if((obs.center-obs2.center).norm() > 500 && (theRobotPose.translation-obs2.center).norm() > 500.f){
                    // if obs2 is in the line of obs1 and passpointA, this is to be not added to marking
                    if(libCheck.distanceToLine(obs2.center,passPointA,obs.center) < 250.f){
                        float maxDist = (passPointA - obs.center).norm();
                        if((obs2.center-obs.center).norm() < maxDist && (obs2.center-passPointA).norm() < maxDist){
                            skip = true;
                            break;
                        }
                    }
                }
            }
            if((obs.center-passPointA).norm() > 800 && !skip)
                PossibleMarkTargets.emplace_back(obs.center);
        }
    }

    Vector2f leastXAboveStriker(std::numeric_limits<float>::max(),std::numeric_limits<float>::max());
    Vector2f leastXBelowStriker(std::numeric_limits<float>::max(),-std::numeric_limits<float>::max());

    for(auto const& obs : PossibleMarkTargets){
        if(obs.y() > strikerPosition.y()){
            if(obs.x() < leastXAboveStriker.x())
                leastXAboveStriker = obs;
        }
        else{
            if(obs.x() < leastXBelowStriker.x())
                leastXBelowStriker = obs;
        }
    }

    // If no mark target
    if(leastXAboveStriker.x() == std::numeric_limits<float>::max() && leastXBelowStriker.x() == std::numeric_limits<float>::max()){
        if(std::abs(strikerPosition.y()) < 500.f){
            if(defenderPosition.y() < strikerPosition.y()){
                float theXPos = (strikerPosition.x()+defenderPosition.x())/2;
                float theYPos = (defenderPosition.y()+strikerPosition.y())/2+1800.f;

                if(theXPos > 0.f){
                    float ratio = theFieldDimensions.xPosOpponentGroundline/(theXPos+theFieldDimensions.xPosOpponentGroundline);
                    theXPos = 0.f;
                    theYPos = theYPos * ratio;
                }
                return Vector2f(theXPos,theYPos);
            }
            else {
                float theXPos = (strikerPosition.x()+defenderPosition.x())/2;
                float theYPos = (defenderPosition.y()+strikerPosition.y())/2-1800.f;

                if(theXPos > 0.f){
                    float ratio = theFieldDimensions.xPosOpponentGroundline/(theXPos+theFieldDimensions.xPosOpponentGroundline);
                    theXPos = 0.f;
                    theYPos = theYPos * ratio;
                }
                return Vector2f(theXPos,theYPos);
            }
        }
        else {
            if(strikerPosition.x() - 500.f > -theFieldDimensions.xPosOpponentGroundline){

                float theXPos = strikerPosition.x() - 500.f;
                float theYPos = strikerPosition.y() - 1800.f;

                if(strikerPosition.y() < 0.f)
                    theYPos = strikerPosition.y() + 1500.f;

                if(theXPos > 0.f){
                    float ratio = theFieldDimensions.xPosOpponentGroundline/(theXPos+theFieldDimensions.xPosOpponentGroundline);
                    theXPos = 0.f;
                    theYPos = theYPos * ratio;
                }

                return Vector2f(theXPos,theYPos);
            }
            else {
                float theXPos = strikerPosition.x();
                float theYPos = strikerPosition.y() - 1800.f;

                if(strikerPosition.y() < 0.f)
                    theYPos = strikerPosition.y() + 1500.f;

                if(theXPos > 0.f){
                    float ratio = theFieldDimensions.xPosOpponentGroundline/(theXPos+theFieldDimensions.xPosOpponentGroundline);
                    theXPos = 0.f;
                    theYPos = theYPos * ratio;
                }
                return Vector2f(theXPos,theYPos);
            }
        }
    }
    // Mark the one below striker
    else if(leastXAboveStriker.x() == std::numeric_limits<float>::max()){
        float theXPos = (leastXBelowStriker.x()*7 + passPointA.x()*3)/10-STAY_BACK_DISTANCE;
        float theYPos = (leastXBelowStriker.y()*7+passPointA.y()*3)/10;

        if(theXPos < -theFieldDimensions.xPosOpponentGroundline)
            theXPos += STAY_BACK_DISTANCE;

        if(theXPos > 0.f){
            float ratio = theFieldDimensions.xPosOpponentGroundline/(theXPos+theFieldDimensions.xPosOpponentGroundline);
            theXPos = 0.f;
            theYPos = theYPos * ratio;
        }
        return Vector2f(theXPos,theYPos);
    }
    // Mark the one above striker
    else if(leastXBelowStriker.x() == std::numeric_limits<float>::max()){
        float theXPos = (leastXAboveStriker.x()*7 + passPointA.x()*3)/10-STAY_BACK_DISTANCE;
        float theYPos = (leastXAboveStriker.y()*7+passPointA.y()*3)/10;

        if(theXPos < -theFieldDimensions.xPosOpponentGroundline)
            theXPos += STAY_BACK_DISTANCE;

        if(theXPos > 0.f){
            float ratio = theFieldDimensions.xPosOpponentGroundline/(theXPos+theFieldDimensions.xPosOpponentGroundline);
            theXPos = 0.f;
            theYPos = theYPos * ratio;
        }

        return Vector2f(theXPos,theYPos);
    }
    // Mark the nearest one
    else {
        if((leastXAboveStriker - theRobotPose.translation).norm() < (leastXBelowStriker - theRobotPose.translation).norm()){
            float theXPos = (leastXAboveStriker.x()*7 + passPointA.x()*3)/10-STAY_BACK_DISTANCE;
            float theYPos = (leastXAboveStriker.y()*7+passPointA.y()*3)/10;

            if(theXPos < -theFieldDimensions.xPosOpponentGroundline)
                theXPos += STAY_BACK_DISTANCE;

            if(theXPos > 0.f){
                float ratio = theFieldDimensions.xPosOpponentGroundline/(theXPos+theFieldDimensions.xPosOpponentGroundline);
                theXPos = 0.f;
                theYPos = theYPos * ratio;
            }

            return Vector2f(theXPos,theYPos);
        }
        else{
            float theXPos = (leastXBelowStriker.x()*7 + passPointA.x()*3)/10-STAY_BACK_DISTANCE;
            float theYPos = (leastXBelowStriker.y()*7+passPointA.y()*3)/10;

            if(theXPos < -theFieldDimensions.xPosOpponentGroundline)
                theXPos += STAY_BACK_DISTANCE;

            if(theXPos > 0.f){
                float ratio = theFieldDimensions.xPosOpponentGroundline/(theXPos+theFieldDimensions.xPosOpponentGroundline);
                theXPos = 0.f;
                theYPos = theYPos * ratio;
            }

            return Vector2f(theXPos,theYPos);
        }
    }
};

libCheck.getSupportStrikerPosition = [&] () -> Vector2f
{
    Vector2f strikerPosition;

    for(const auto& teammate : theTeamData.teammates){
        if(teammate.role == Role::RoleType::striker) {
            strikerPosition = Vector2f(teammate.theRobotPose.translation.x(),teammate.theRobotPose.translation.y());
        }
    }

    float theXPos = strikerPosition.x() - 600.f;
    float theYPos = strikerPosition.y()/2;
    if(std::abs(theYPos) < 600.f){
        if(theYPos < 0.f)
            theYPos = strikerPosition.y() + 600.f;
        else
            theYPos = strikerPosition.y() - 600.f;
    }

    // if we're defending really close to our goal
    if(strikerPosition.x() < 600.f-theFieldDimensions.xPosOpponentGroundline){
        theXPos = strikerPosition.x() + 200.f;
        if(strikerPosition.y() < 0.f)
            theYPos = strikerPosition.y() + 600.f;
        else
            theYPos = strikerPosition.y() - 600.f;
    }

    // If we're attacking, stay at x=0
    if(theXPos > 0){
        float ratio = theFieldDimensions.xPosOpponentGroundline/(theXPos+theFieldDimensions.xPosOpponentGroundline);
        theXPos = 0;
        theYPos = theYPos * ratio;
    }

    return Vector2f(theXPos,theYPos);

};

libCheck.getSupporterPosition = [&] () -> Vector2f
{
    // if the ball is free
    if(theRoleAndContext.ball_holding_Context == 0){
        float myDistanceToBall = (theRobotPose.translation-theTeamBallModel.position).norm() + 1000.f;
        bool amNearest = true;
        for(const auto& teammate : theTeamData.teammates){
            if(!teammate.isGoalkeeper && teammate.number != theRobotInfo.number) {
                if((teammate.theRobotPose.translation-theTeamBallModel.position).norm() < myDistanceToBall){
                    amNearest = false;
                    break;
                }
            }
        }
        if(amNearest)
            return theTeamBallModel.position;
    }

    Vector2f thePosition;

    if(theRoleAndContext.ball_holding_Context == 2 ||   theRoleAndContext.ball_holding_Context == 3){
        if(theTeamBallModel.position.x() < 0 || libCheck.opponentOnOurField())
            thePosition = libCheck.getSupporterMarkPosition();
        else {
            thePosition = libCheck.getSupportStrikerPosition();
        }
    }
    else{
        if(theTeamBallModel.position.x() < 0 || !libCheck.opponentOnOurField())
            thePosition = libCheck.getSupportStrikerPosition();
        else
            thePosition = libCheck.getSupporterMarkPosition();
    }

    if(!libCheck.obstacleExistsAroundPoint(thePosition))
        return thePosition;
    else {
        if(thePosition.x()-500.f > -theFieldDimensions.xPosOpponentGroundline){
            if(!libCheck.obstacleExistsAroundPoint(Vector2f(thePosition.x()-500.f,thePosition.y())))
                return Vector2f(thePosition.x()-500.f,thePosition.y());
        }
        else if(thePosition.x()+500.f < 0){
            if(!libCheck.obstacleExistsAroundPoint(Vector2f(thePosition.x()-500.f,thePosition.y())))
                return Vector2f(thePosition.x()+500.f,thePosition.y());
        }
        else
            return thePosition;
    }
    return thePosition;
};

  
  
  libCheck.getJollyPosition = [&] () -> Vector2f
{
  // to return
  Vector2f jollyPosition = Vector2f(0,0);

  // take ball position
  Vector2f ballPosition;
  ballPosition = theTeamBallModel.position;

  // decide the side, should be the opposite
  if(ballPosition.y() < 0.f) {
    if(ballPosition.x() > theFieldDimensions.xPosOpponentPenaltyMark) {
      jollyPosition.y() = theFieldDimensions.yPosLeftSideline - 2000.f;
    } else {
        jollyPosition.y() = theFieldDimensions.yPosLeftSideline - 1000.f;
    }
  } else {
        if(ballPosition.x() > theFieldDimensions.xPosOpponentPenaltyMark) {
             jollyPosition.y() = theFieldDimensions.yPosRightSideline + 2000.f;
        } else {
    jollyPosition.y() = theFieldDimensions.yPosRightSideline + 1000.f;
  }
        }

  // if the ball is not ahead of the previous jolly position by 1m
  // take previous y
  for(const auto& mate : theTeamData.teammates) {
    if(mate.role == Role::RoleType::jolly) {
      // check jolly position w.r.t. ball
      if(ballPosition.x()+500.f < 0.f) {
        jollyPosition.y() = -1500.f;
      } else if(ballPosition.x() > mate.theRobotPose.translation.x()+1000.f) {
        jollyPosition.y() = mate.theRobotPose.translation.y();
      }
    }
  }

  jollyPosition.x() = theFieldDimensions.xPosOpponentGroundline*0.6f;
  Vector2f translation = Vector2f(0.f, 0.f);
  for(unsigned i=0; i<4; ++i) {
    jollyPosition = jollyPosition+translation;
    // compute best passing line
    Eigen::ParametrizedLine<float,2> toBall = Eigen::ParametrizedLine<float,2>::Through(jollyPosition, ballPosition);

    float minDist = std::numeric_limits<float>::max();
    for(auto obs : theTeamPlayersModel.obstacles) {
      if(obs.center.x() > ballPosition.x() && obs.center.x() < jollyPosition.x()){
        if(obs.isOpponent()) {
          float thisDist = toBall.distance(obs.center);
          if(thisDist < minDist)
            minDist = thisDist;
        }
      }
    }

    if(minDist > 500.f) {
      return jollyPosition;
    }

    // increment translation
    translation.x() = translation.x()-300.f;
  }

  return jollyPosition;
};

libCheck.opponentOnOurField = [&] () -> bool
{
    for(auto const& obs : theTeamPlayersModel.obstacles){
        if(obs.isOpponent() && obs.center.x() < 0.f){
            return true;
        }
    }
    return false;
};
  
  libCheck.distanceToLine = [&] (Vector2f objectToCheck, Vector2f linePoint1, Vector2f linePoint2) -> float
{
    return std::abs(((linePoint2.y()-linePoint1.y())*objectToCheck.x()) - ((linePoint2.x() - linePoint1.x()) * objectToCheck.y())
    + (linePoint2.x() * linePoint1.y()) - (linePoint2.y() * linePoint1.x())) / ((linePoint1-linePoint2).norm());
};

libCheck.obstacleExistsAroundPoint = [&] (Vector2f point) -> bool
{
    for(const auto& obstacle : theObstacleModel.obstacles){
        if((obstacle.center - point).norm() < 400.f){
            return true;
        }
    }
    return false;
};
  
  libCheck.defenderPosition = updateDefender();
  libCheck.supporterPosition = updateSupporter();
  //libCheck.goaliePosition = updateGoalie();
  libCheck.jollyPosition = Vector2f(theFieldDimensions.yPosLeftGoal, theFieldDimensions.yPosRightGoal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////END OF UPDATE////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void LibCheckProvider::reset()
{
  FOREACH_ENUM(LibCheck::CheckedOutput, i)
    callCounters[i] = 0;

  for(int i = 0; i < Arms::numOfArms; ++i)
    setArmsInThisFrame[i] = false;
}

void LibCheckProvider::checkOutputs(const ActivationGraph& activationGraph, LibCheck::CheckedOutput start, LibCheck::CheckedOutput end) const
{
  const std::string options = getActivationGraphString(activationGraph);

  // Output counting checks:
  for(LibCheck::CheckedOutput i = start; i < end; i = static_cast<LibCheck::CheckedOutput>(static_cast<unsigned>(i) + 1))
  {
    // Check, if output has been set at least once:
    if(callCounters[i] == 0 && notSetCheck[i] == 1)
    {
      OUTPUT_TEXT("Meeek! " << TypeRegistry::getEnumName(i) << " has not been set in this cycle (Robot " << theRobotInfo.number
                  << (!callCounters[LibCheck::role] ? "" : ", Role: " + theTeamBehaviorStatus.role.getName())
                  << (options == "" ? "" : ", Options: " + options) << ") !");
    }
    else if(notSetCheck[i] == 2)
    {
      ASSERT(callCounters[i] > 0);
    }
  }
}


void LibCheckProvider::checkMotionRequest(const ActivationGraph& activationGraph, const MotionRequest& theMotionRequest) const
{
  // Check for invalid motion request:
  if(assertValidWalkRequest &&
     theMotionRequest.motion == MotionRequest::walk &&
     !theMotionRequest.walkRequest.isValid())
  {
#ifndef NDEBUG
    {
      std::string logDir = "";
#ifdef TARGET_ROBOT
      logDir = "../logs/";
#endif
      OutMapFile stream(logDir + "walkRequest.log");
      stream << theMotionRequest.walkRequest;
      stream << getActivationGraphString(activationGraph);
    }
#endif
    FAIL("Motion request is not valid (see walkRequest.log).");
  }
}

void LibCheckProvider::inc(LibCheck::CheckedOutput outputToCheck)
{
  const int index = static_cast<int>(outputToCheck);
  if(index >= 0 && index < LibCheck::numOfCheckedOutputs)
  {
    ++callCounters[index];

    // Check, if output has not been set more than once:
    if(callCounters[index] > 1)
    {
      if(multipleSetCheck[index] == 1)
      {
        const std::string options = getActivationGraphString(index >= LibCheck::firstTeamCheckedOutput ? theTeamActivationGraph : theActivationGraph);

        OUTPUT_TEXT("Meeek! " << TypeRegistry::getEnumName(static_cast<LibCheck::CheckedOutput>(index)) << " has been set more than once in this cycle (Robot "
                    << theRobotInfo.number
                    << (!callCounters[LibCheck::role] ? "" : ", Role: " + theTeamBehaviorStatus.role.getName())
                    << (options == "" ? "" : ", Options: " + options) << ") !");
      }
      else if(multipleSetCheck[index] == 2)
      {
        ASSERT(callCounters[index] <= 1);
      }
    }
  }
}

Pose2f LibCheckProvider::myReadyPosition() const{
  Pose2f strikerPose = Pose2f(0.f, -1000.f, 0.f);
  if(theGameInfo.kickingTeam == theOwnTeamInfo.teamNumber){
    strikerPose = Pose2f(0.f, -500.f, 0.f);
  }else{
    strikerPose = Pose2f(0.f, -1000.f, 0.f);
  }
  
  Pose2f goaliePose = Pose2f(0.f, theFieldDimensions.xPosOwnGroundline + 200.f, 0.f);
  Pose2f defenderPose = Pose2f(0.f, theFieldDimensions.xPosOwnGroundline + 1000.f, -1000.f);
  Pose2f jollyPose = Pose2f(0.f, -500.f, -1500.f);
  Pose2f supporterPose = Pose2f(0.f, theFieldDimensions.xPosOwnGroundline + 1700.f, 800.f);
  int activeTeam = 0;
  int lowerNumbers = 0;
  if(theRobotInfo.penalty == PENALTY_NONE){
    activeTeam++;
  }
  if(theRobotInfo.number == 1){
      return goaliePose;
  }
  for( auto teammate : theTeamData.teammates ){
    if(teammate.status != Teammate::PENALIZED && teammate.number != 1){
      activeTeam ++;
      if(teammate.number < theRobotInfo.number){
        lowerNumbers ++;
      }
    }
  }
  switch(activeTeam){
    case 0: return Pose2f(0.f,0.f,0.f); break;

    case 1: return strikerPose;
            break;

    case 2: if(lowerNumbers <= 0){
              return defenderPose;
            }else{
              return strikerPose;
            } 
            break;

    case 3: if(lowerNumbers == 2){
                return strikerPose;
              }else if(lowerNumbers == 1){
                return defenderPose;
              }else if(lowerNumbers == 0){
                return supporterPose;
              }
              break;

    case 4: if(theRobotInfo.number == 3){
              return strikerPose;
            }else if(theRobotInfo.number == 2){
              return supporterPose;
            }else if (theRobotInfo.number == 5){
              return defenderPose;
            }else if(theRobotInfo.number == 4){
              return jollyPose;
            }
  }

  return strikerPose;

}

float LibCheckProvider::distance(Pose2f p1, Pose2f p2) const{

  return static_cast<float>( std::sqrt( std::pow(p2.translation.x() - p1.translation.x(), 2) + 
    std::pow(p2.translation.y() - p1.translation.y(), 2) ) );

}

std::string LibCheckProvider::getActivationGraphString(const ActivationGraph& activationGraph) const
{
  std::string options = "";
  for(const auto& node : activationGraph.graph)
    options += (options == "" ? "" : ", ") + node.option + (node.state == "" ? "" : "/" + node.state);
  return options;
}

Pose2f LibCheckProvider::refineTarget(Pose2f t, float d){
  
  Rangef zeroTreshold = Rangef({-0.1f, 0.1f});
  float diffX = t.translation.x() - theRobotPose.translation.x();
  float diffY = t.translation.y() - theRobotPose.translation.y();

  //Check if target and robot have the same X
  if(zeroTreshold.isInside(diffX)){
    //if they also have the same y keep the same target
    if(zeroTreshold.isInside(diffY)){
      return t;
    }else{
      return Pose2f(theRobotPose.translation.x(), theRobotPose.translation.y() + (d * sign(diffY) ));
    }
  }// end of if X1 == X2

  //Check if target and robot have the same Y
  if(zeroTreshold.isInside(diffY)){
    //if they also have the same x keep the same target
    if(zeroTreshold.isInside(diffX)){
      return t;
    }else{
      return Pose2f( theRobotPose.translation.x() + (d * sign(diffX)) , theRobotPose.translation.y());
    }
  }// end of if Y1 == Y2

  //if the distance is still lower than d, than just return t
  if(distance(theRobotPose, t) <= d ){
    return t;
  }

  // Y = mX + q
  float m = diffY/diffX;
  float q = -theRobotPose.translation.y() -theRobotPose.translation.x()*m;  
  // just for readability
  float x1 = theRobotPose.translation.x();
  float y1 = theRobotPose.translation.y();
  
  float a = SQ(m) + 1;
  float b = 2*m -2*y1*m -2*x1;
  float c = SQ(q) -2*y1*q +SQ(y1) +SQ(x1) -SQ(d);
  
  //Use the delta formula
  float X = (-b + std::sqrt(SQ(b) - 4*a*c))/(2*a);
  //classical line equation
  float Y = m*X + q;

  return Pose2f(X,Y);

}

//RECENTLY ADDED
//Emanuele M
float LibCheckProvider::projectGazeOntoOpponentGroundline()
{
    return theRobotPose.translation.y() + std::abs(theFieldDimensions.xPosOpponentGoal - theRobotPose.translation.x())*tan(theRobotPose.rotation);
}

//RECENTLY ADDED
//Emanuele M
//TODO
float LibCheckProvider::areaValueHeuristic(const float begin, const float end)
{
  return 0.0;
}

//RECENTLY MODIFIED
//Emanuele M
std::vector<FreeGoalTargetableArea> LibCheckProvider::computeFreeAreas()
{
  //my pose
  Pose2f myPose = Pose2f(theRobotPose.translation);
  
  //build vector of opponents
  std::vector<Obstacle> opponents;
  for(auto obs : theTeamPlayersModel.obstacles){
    opponents.push_back(obs);
  }

  //array of opponent goal poles positions:
  //CHECK FOR NEW ROBOCUP FIELD SPECIFICATIONS
  Pose2f goalPoints[2];
  goalPoints[0].translation.x() = (float)theFieldDimensions.xPosOpponentGroundline;
  goalPoints[1].translation.x() = (float)theFieldDimensions.xPosOpponentGroundline;
  goalPoints[0].translation.y() = 730.;
  goalPoints[1].translation.y() = -730.;

  std::vector<float> leftPoints;
  std::vector<float> rightPoints;
  std::vector<FreeGoalTargetableArea> freeAreas;

  //UNUSED
  //my distance from opponent goal
  float div1;
  if((goalPoints[0].translation.x() - myPose.translation.x() ) == 0){
    div1 = 0.1f;
  } else {
    div1 = (float)((goalPoints[0].translation.x() - myPose.translation.x()));
  }

  // y = ((4500 - x1)/(x2 - x1))*(y2 -y1) + y1

  // float firstM = (goalPoints[0].translation.y() - myPose.translation.y() )/div1;
  // float secondM = (goalPoints[1].translation.y() - myPose.translation.y() )/div2;
  unsigned i, k;
  Obstacle swapper;

  //first sweep: sort the opponents in vector based on the y coordinate of their left points (as obstacles, it is the leftmost point i see)
  for(i = 0; i < opponents.size(); i++){
      for(k = 0; k < opponents.size(); k++){
          if(opponents.at(i).left.y() > opponents.at(k).left.y() ){
              swapper = opponents.at(k);
              opponents.at(k) = opponents.at(i);
              opponents.at(i) = swapper;
          }
      }
  }

  //second sweep: push the globalized left and right points of each obstacle 
  for(i = 0; i < opponents.size(); i++){
      if((opponents.at(i).left.x() - myPose.translation.x()) == 0){
        div1 = 0.1f;
      } else {
        div1 = (float)(opponents.at(i).left.x() - myPose.translation.x());
      }

      float y = ((theFieldDimensions.xPosOpponentGroundline - myPose.translation.x())/div1)*(opponents.at(i).left.y() - myPose.translation.y()) + myPose.translation.y();
      leftPoints.push_back(y);
  }

  for(i = 0; i < opponents.size(); i++){
      if((opponents.at(i).right.x() - myPose.translation.x()) == 0){
        div1 = 0.1f;
      } else {
        div1 = (float)(opponents.at(i).right.x() - myPose.translation.x());
      }

      float y = ((theFieldDimensions.xPosOpponentGroundline - myPose.translation.x())/div1)*(opponents.at(i).right.y() - myPose.translation.y()) + myPose.translation.y();
      rightPoints.push_back(y);
  }

  //gestisco caso in cui tutti gli obstacle sono fuori dalla porta
  bool noneInside = true;
  float begin = 730.;
  float end = -730.;

  for(i = 0; i < leftPoints.size(); i++){
      //caso 1
      if((leftPoints.at(i) < 730. && leftPoints.at(i) > -730.) || (rightPoints.at(i) < 730. && rightPoints.at(i) > -730.)){
          noneInside = false;
      }
      if(leftPoints.at(i) > 730. && rightPoints.at(i) < 730.){
          begin = rightPoints.at(i);

      }
      if(leftPoints.at(i) > -730. && rightPoints.at(i) < -730.){
          end = leftPoints.at(i);

      }
  }
  if(noneInside == true){
  //    freeAreas.push_back(begin);
    freeAreas.push_back(FreeGoalTargetableArea(begin, end, areaValueHeuristic(begin,end)));
  //    freeAreas.push_back(end);
      return freeAreas;
  }
  std::vector<float> freeAreasPoints;
  freeAreasPoints.push_back(begin);
  for(i = 0; i < leftPoints.size(); i++){
      if(leftPoints.at(i) < begin && leftPoints.at(i) > end){
          freeAreasPoints.push_back(leftPoints.at(i));
      }
      if(rightPoints.at(i) > end && rightPoints.at(i) < begin){
          freeAreasPoints.push_back(rightPoints.at(i));
      }
  }
  freeAreasPoints.push_back(end);

  //FIND NEAREST USABLE FREE AREA AND DETERMINE MOST ACCESSIBLE TARGET
  if(freeAreasPoints.size()%2 == 0)
  {
    for(i = 0; i < freeAreasPoints.size() -1; i+=2)
    {
      freeAreas.push_back(FreeGoalTargetableArea(freeAreasPoints.at(i), freeAreasPoints.at(i+1), areaValueHeuristic(freeAreasPoints.at(i),freeAreasPoints.at(i+1))));
    }
  }
  else
  {
    for(i = 1; i < freeAreasPoints.size() -1; i+=2)
    {
      freeAreas.push_back(FreeGoalTargetableArea(freeAreasPoints.at(i), freeAreasPoints.at(i+1), areaValueHeuristic(freeAreasPoints.at(i),freeAreasPoints.at(i+1))));
    }
  }

  return freeAreas;
};

Pose2f LibCheckProvider::goalTarget() {
    //std::vector<FreeGoalTargetableArea> freeAreas = computeFreeAreas();
    std::vector<FreeGoalTargetableArea> freeAreas = theOpponentGoalModel.freeGoalTargetableAreas;

    for(auto area : freeAreas)
    {
      std::cout << ("KICKING: FreeGoalTargetableArea: ("+std::to_string(area.begin)+","+std::to_string(area.end)+")") << "\n";
    }

    //Find nearest opponent
    //float nearestObstacleThreshold = 200.f;
    std::vector<Obstacle> opponents;
    for(auto obs : theTeamPlayersModel.obstacles){
      opponents.push_back(obs);
    }

    float ARBITRARILY_HIGH_VALUE = 100000.f;
    float minOpponentDistance=ARBITRARILY_HIGH_VALUE;
    Obstacle nearestOpponent;
    
    for(unsigned i = 0; i < opponents.size(); i++){
      if(distance(theRobotPose.translation,opponents.at(i).center)<minOpponentDistance){
        minOpponentDistance = distance(theRobotPose.translation,opponents.at(i).center);
        nearestOpponent = opponents.at(i);
      }
    }

    //project my line of view onto the goal line
    float myGazeProjection = theOpponentGoalModel.myGazeProjection;
    float GOAL_DISTANCE_THRESHOLD = 300.f;

    //TODO: se vuoi, controllo che il punto in cui vado a calciare sia > del più vicino limite della free area + il raggio della palla

    float targetPoint = 0;

    //CASE 1: I'm near the goal post -> choose the nearest free area
    if(std::abs(theRobotPose.translation.x()-theFieldDimensions.xPosOpponentGoal)<GOAL_DISTANCE_THRESHOLD){
      for(unsigned i = 0; i < freeAreas.size(); i++){
        //CASE 1.1: Looking at free area directly
        if(myGazeProjection>freeAreas.at(i).begin && myGazeProjection<freeAreas.at(i).end){
          targetPoint = myGazeProjection;
        }
        //CASE 1.2: Looking away from free area
        //TODO: Find nearest free area and target the nearest accessible point
        else
        {
          
        }
      }
    }
    //CASE 2: I'm far away from the goal post -> find the largest free area (MIGHT BECOME "FIND THE BEST FREE AREA, BASED ON ITS HEURISTIC VALUE")
    else
    {
      float maxInterval = 0;
      unsigned maxIndex = 0;
      //FIND LARGEST FREE AREA AND DETERMINE THE MOST ACCESSIBLE TARGET
      for(unsigned i = 0; i < freeAreas.size(); i++){
        if(maxInterval < freeAreas.at(i).interval){
          maxInterval = freeAreas.at(i).interval;
          maxIndex = i;
          targetPoint = freeAreas.at(i).midpoint;
        }
      }
    }

    Pose2f target;
    if (theRobotPose.translation.x() >= (theFieldDimensions.xPosOpponentGroundline - 600.f) &&
            std::abs(theRobotPose.translation.y()) < 500.f )
        target = Pose2f(theFieldDimensions.xPosOpponentGroundline + 1000.f, targetPoint);
    else
        target = Pose2f(theFieldDimensions.xPosOpponentGroundline, targetPoint);
      return target;
  };
  

Pose2f LibCheckProvider::glob2Rel(float x, float y)
{
    Vector2f result;
    float theta = 0;
    float tempX = x - theRobotPose.translation.x();
    float tempY = y - theRobotPose.translation.y();

    result.x() = (float)(tempX * cos(theRobotPose.rotation) + tempY * sin(theRobotPose.rotation));
    result.y() = (float)(-tempX * sin(theRobotPose.rotation) + tempY * cos(theRobotPose.rotation));

    return Pose2f(theta /*deg*/, result.x(),result.y());
}

Pose2f LibCheckProvider::rel2Glob(float x, float y)
{
    Vector2f result;
    float rho = (float)(sqrt((x * x) + (y * y)));

    result.x() = (float)(theRobotPose.translation.x() + (rho * cos(theRobotPose.rotation + atan2(y,x))));
    result.y() = (float)(theRobotPose.translation.y() + (rho * sin(theRobotPose.rotation + atan2(y,x))));

    return Pose2f(result.x(),result.y());
}

Vector2f LibCheckProvider::updateDefender()
{
    return Vector2f(theFieldDimensions.xPosOwnPenaltyMark+100, -700.f);
}

Vector2f LibCheckProvider::updateSupporter()
{
    return Vector2f(-1750.f, +700.f);
}

bool LibCheckProvider::isGoalieInStartingPosition() {

   if( isValueBalanced(theRobotPose.translation.x(), SPQR::GOALIE_BASE_POSITION_X+1000, SPQR::GOALIE_POSE_X_TOLLERANCE) &&
            isValueBalanced(theRobotPose.translation.y(), SPQR::GOALIE_BASE_POSITION_Y+1000, SPQR::GOALIE_POSE_Y_TOLLERANCE) )
        return true;
    else
        return false;
}

bool LibCheckProvider::isValueBalanced(float currentValue, float target, float bound) {
      float minErr = currentValue - (target - bound);
    float maxErr = currentValue - (target + bound);

    if( std::abs(minErr) < bound*1.2 && std::abs(maxErr) < bound*1.2 )
        return true;
    else
        return false;
}

bool LibCheckProvider::isBallInKickAwayRange()
{
    if( theBallModel.estimate.position.norm() < SPQR::GOALIE_KICK_AWAY_RANGE )
        return true;
    else
        return false;
}

bool LibCheckProvider::isGoalieInKickAwayRange()
{
    Pose2f gloBall = rel2Glob(theBallModel.estimate.position.x(), theBallModel.estimate.position.y());
    if (between(gloBall.translation.x(), theFieldDimensions.xPosOwnGroundline, theFieldDimensions.xPosOwnPenaltyArea+100) && between(gloBall.translation.y(), theFieldDimensions.yPosRightPenaltyArea-100, theFieldDimensions.yPosLeftPenaltyArea+100))
        return true;
    else
        return false;
}

bool LibCheckProvider::isBallInArea()
{
    Pose2f gloBall = rel2Glob(theBallModel.estimate.position.x(), theBallModel.estimate.position.y());
    if (between(gloBall.translation.x(), theFieldDimensions.xPosOwnGroundline, theFieldDimensions.xPosOwnPenaltyArea) && between(gloBall.translation.y(), theFieldDimensions.yPosRightPenaltyArea, theFieldDimensions.yPosLeftPenaltyArea))
        return true;
    else
        return false;
}

bool LibCheckProvider::isGoalieInArea()
{
    if (between(theRobotPose.translation.x(), theFieldDimensions.xPosOwnGroundline, theFieldDimensions.xPosOwnPenaltyArea) && between(theRobotPose.translation.y(), theFieldDimensions.yPosRightPenaltyArea, theFieldDimensions.yPosLeftPenaltyArea))
        return true;
    else
        return false;
}

bool LibCheckProvider::isGoalieInAngle()
{
    //~ if(isBallInCoverRange())
        //~ if (between(angleToTarget(theBallModel.estimate.position.x(), theBallModel.estimate.position.y()),
                //~ Angle::fromDegrees(-10.f),
                //~ Angle::fromDegrees(10.f) ) )
            //~ return true;
        //~ else
            //~ return false;
    //~ else
        if (between(theRobotPose.rotation, Angle::fromDegrees(-10.f), Angle::fromDegrees(10.f) ))
            return true;
        else
            return false;
}

float LibCheckProvider::angleToTarget(float x, float y)
{
    //gets the relative position of the point to go for the robot
    Pose2f relativePosition = glob2Rel(x,y);
    //std::cerr << "y relativa: "<< relativePosition.translation.y() << ", x relativa: "<<relativePosition.translation.x() << std::endl;
    //return radiansToDegree(atan2f(relativePosition.translation.y(), relativePosition.translation.x()));
    return (atan2f(relativePosition.translation.y(), relativePosition.translation.x()));

    //return glob2Rel(x, y).translation.angle();
}


